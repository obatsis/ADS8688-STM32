----------------------------------------------------------------------------------
CAN Peripheral IOC Setup 168 Mhz
Prescaler: 2
Time quanta1: 16
Time quanta2: 4
resync: 1
auto-bus-off: enabled
all the other desabled
+ enable rx interrupt
----------------------------------------------------------------------------------
stm32f4xx_it.c
extern void CAN1_Rx();
extern void CAN2_Rx();

void CAN1_RX0_IRQHandler(void)
{
  /* USER CODE BEGIN CAN1_RX0_IRQn 0 */
	CAN1_Rx();
  /* USER CODE END CAN1_RX0_IRQn 0 */
  HAL_CAN_IRQHandler(&hcan1);
  /* USER CODE BEGIN CAN1_RX0_IRQn 1 */

  /* USER CODE END CAN1_RX0_IRQn 1 */
}
----------------------------------------------------------------------------------
main.c (cooling)
#define max(x,y) (((x)>(y)) ? (x) : (y))
uint8_t fan_per[4] = {25, 50, 75, 100};
  HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adc_buf, ADC_BUF_LEN);
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
  __HAL_TIM_SET_COMPARE(&htim3,TIM_CHANNEL_1, max(fan, fan_overr));		// it must be placed inside a temperature condition
  current=HAL_GetTick();
	  if(pumps && (max(water_temp_0, water_temp_1) >= fan_on_thres)) {						// fan auto temperature control
//		  fan = fan_per[map_fan(max(water_tmp[0], water_tmp[1]), fan_on_thres, 65, 0, 3)];
		  uint8_t temp_tmp = max(water_temp_0, water_temp_1);
		  if(temp_tmp >= 55) fan = fan_per[3];
		  else if (temp_tmp >= 45) fan = fan_per[2];
		  else if (temp_tmp >= 38) fan = fan_per[1];
		  else fan = fan_per[0];

	  }
	  if(msg_previous<current) {								// msg send control
		  HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);

		  analog_val_0 = ((float)water_tmp[0])*3.3/4095.0;
		  analog_val_1 = ((float)water_tmp[1])*3.3/4095.0;
		 // water_temp_0 = (int)((440*(analog_val_0+0.04)-1200)/(0.385*(12-analog_val_0+0.04)));
		 //water_temp_1 = (int)((440*(analog_val_1+0.04)-1200)/(0.385*(12-analog_val_1+0.04)));

		  water_temp_0 = (int)(((440*(analog_val_0+0.04))/(12-analog_val_0+0.04)-100)/0.385);
		  water_temp_1 = (int)(((440*(analog_val_1+0.04))/(12-analog_val_1+0.04)-100)/0.385);
		 


		  //water_temp_0 = (int)((analog_val_0-2,727)/0.005);
		  //water_temp_1 = (int)((analog_val_1-2,727)/0.005);

		  msg[0] = /*(water_temp_0)*/ 0;
		  msg[1] = water_temp_1 ;
		  msg[2] = max(fan, fan_overr);

		  msg[3] = 0;
		  msg[3]|= pumps<<0;
		  msg[3]|= motor_temp_too_high<<1;
		  msg[3]|= device_temp_too_high<<2;
		  msg[3]|= motor_temp_limit_reach<<3;
		  msg[3]|= device_temp_limit_reach<<4;


		  msg[4]= igbt_temp;
		  msg[5]= motor_temp;

		  CAN_Tx(std_ID, 6, msg);
		  time=0;
		  msg_previous=current;
		  msg_previous+=msg_interval;

	  }
	  adcVal1=adc_buf[0];
	  adcVal2=adc_buf[1];
	  //adcVal1[time]=adc_buf[0];
	  //adcVal2[time]=adc_buf[1];
	  if(time==smooth-1) {
		  /*for(int i=0; i<smooth; i++) {
			  final[0]+=adcVal1[i];
			  final[1]+=adcVal2[i];
		  }*/
		  final[0]/=smooth;
		  final[1]/=smooth;
		  water_tmp[0]=final[0];
		  water_tmp[1]=final[1];
		  time=0;
	  }
	  else {
		  final[0]+=adcVal1;
	          final[1]+=adcVal2;
		  time++;
	  }

uint8_t map(uint16_t x, uint16_t in_min, uint16_t in_max, uint16_t out_min, uint16_t out_max) {
	if(x<map_min_thres || x>map_max_thres) return 0x00;
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

uint8_t map_fan(uint16_t x, uint16_t in_min, uint16_t in_max, uint16_t out_min, uint16_t out_max) {
  uint8_t res = (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  if(res>=3) res =3;
  return res;
}
----------------------------------------------------------------------------------
2_pot_freq_duty

void adjust_PWM_DC(TIM_HandleTypeDef* const pwmHandle, uint16_t freq, uint16_t duty) {

	pwmHandle->Instance->ARR =freq;
    /* The duty cycle value is a percentage of the reload register value (ARR). Rounding is used.*/
    uint32_t newRegVal = (uint32_t)roundf((pwmHandle->Instance->ARR) * (duty * 0.01F));

    /*In case of the DC being calculated as higher than the reload register, cap it to the reload register*/
//    if(newRegVal > pwmHandle->Instance->ARR){
//        newRegVal = pwmHandle->Instance->ARR;
//    }

    /*Assign the new DC count to the capture compare register.*/
    pwmHandle->Instance->CCR1 = (uint32_t)(roundf(newRegVal));  /*Change CCR1 to appropriate channel, or pass it in with function.*/
}


----------------------------------------------------------------------------------
main.c (generic)
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>

#include "stm32f4xx_hal.h"
#include "ADS8688.h"
#include "FLASH_SECTOR.h"

#define USB_DEBUG 1
#define ETH_TCP_DEBUG 1
#define TCP_DEBUG_PORT 6000
#define startport 5000
#define numofports 10
#define numofclients 3

#define default_interval 500
#define default_msg1_interval 100
#define default_msg2_interval 100

#define abs(x) ((x<0)?(-x):(x))

#define BYTE_TO_BIN_PAT "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BIN(byte)		\
	(byte & 0x80 ? '1' : '0'),	\
	(byte & 0x40 ? '1' : '0'),	\
	(byte & 0x20 ? '1' : '0'),	\
	(byte & 0x10 ? '1' : '0'),	\
	(byte & 0x08 ? '1' : '0'),	\
	(byte & 0x04 ? '1' : '0'),	\
	(byte & 0x02 ? '1' : '0'),	\
	(byte & 0x01 ? '1' : '0')

#define ADC_BUF_LEN 2

/* USER CODE BEGIN PV */
CAN_FilterTypeDef FilterConfig0;

CAN_RxHeaderTypeDef RxHeader1;
CAN_TxHeaderTypeDef TxHeader1;
CAN_RxHeaderTypeDef RxHeader2;
CAN_TxHeaderTypeDef TxHeader2;
uint8_t r1[8];
uint8_t r2[8];
// Can messages
uint8_t msg1[8] = {0,0,0,0,0,0,0,0};
uint8_t msg2[8] = {0,0,0,0,0,0,0,0};

char buf[100];

// Timing Variables
unsigned int current=0, previous=0, interval=default_interval;
uint32_t my_ip=0, my_net=0, my_gw=0, phyreg = 0U;

// General variables
uint8_t red_led=0, blue_led=0, green_led=0, dhcp_en=1, request_static=0, button_pressed=0;
uint16_t adc_buf[ADC_BUF_LEN];

// flash variables
uint32_t flash_data[] = {0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000};
__IO uint32_t flash_rx_data[5];
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void print(char *msg, ...);
void CAN1_Tx(uint32_t ID, uint8_t dlc, uint8_t* data);
void CAN1_Rx();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Flash_Read_Data(START_F_ADDRESS_IP, flash_rx_data, 5);
  print("Flash variables:\n");
  for(uint8_t i=0; i<5; i++) {
	  print("%lu\n",flash_rx_data[i]);
	  flash_data[i] = flash_rx_data[i];
  }
  flash_data[0]++;
  if((flash_data[1] & 0x0001) == 1) {
	  dhcp_en = 0;
  }
  Flash_Write_Data(START_F_ADDRESS_IP, flash_data, 5);

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// simple active low button debouncing (enters on first fall and waits for a rise)

	if((HAL_GPIO_ReadPin(GPIOB, AA_BUTTON_Pin)==GPIO_PIN_RESET || aa_press) && previous<current && aa_button==0) {		//additional action
			aa_handle();
			aa_button=1;
			aa_press=0;
			previous=current;
			previous+=button_interval_aa_rtd;
	}
	else if(HAL_GPIO_ReadPin(GPIOB, AA_BUTTON_Pin)==GPIO_PIN_SET && previous<current && aa_button==1) {
		aa_button=0;
	}

// simple active low signal debouncing (enters after a small amount of time has passed with the signal low and then waits for high to reset)

	if(HAL_GPIO_ReadPin(GPIOA, IMD_STATUS_Pin)==GPIO_PIN_RESET && led_imd_prev<current && !imd) {		// imd
		if(led_imd_first) {
			led_imd_prev=current;
			led_imd_prev+=led_interval;
			led_imd_first=0;
		}
		else {
			imd_handle(1);
			led_imd_first=1;
		}
	}
	else if(HAL_GPIO_ReadPin(GPIOA, IMD_STATUS_Pin)==GPIO_PIN_SET){
		led_imd_first=1;
		imd_handle(0);        //den yparxei thoryvos
	}


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
static void MX_CAN1_Init(void) {
  hcan1.Instance = CAN1;
  hcan1.Init.Prescaler = 2;
  hcan1.Init.Mode = CAN_MODE_NORMAL;
  hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan1.Init.TimeSeg1 = CAN_BS1_16TQ;
  hcan1.Init.TimeSeg2 = CAN_BS2_4TQ;
  hcan1.Init.TimeTriggeredMode = DISABLE;
  hcan1.Init.AutoBusOff = ENABLE;
  hcan1.Init.AutoWakeUp = DISABLE;
  hcan1.Init.AutoRetransmission = ENABLE;
  hcan1.Init.ReceiveFifoLocked = DISABLE;
  hcan1.Init.TransmitFifoPriority = DISABLE;
  if (HAL_CAN_Init(&hcan1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN CAN1_Init 2 */
  else {
		Serialprintln("CAN BUS 1 INITIALIZED");
	}
  // override message
	FilterConfig0.FilterIdHigh = over1_ID<<5;
	FilterConfig0.FilterIdLow = 0;
	FilterConfig0.FilterMaskIdHigh = 0xffe0;
	FilterConfig0.FilterMaskIdLow = 0;
	FilterConfig0.FilterFIFOAssignment = CAN_FILTER_FIFO0;
	FilterConfig0.FilterBank = 0;
	FilterConfig0.FilterMode = CAN_FILTERMODE_IDMASK;
	FilterConfig0.FilterScale = CAN_FILTERSCALE_32BIT;
	FilterConfig0.FilterActivation =ENABLE;
	if(HAL_CAN_ConfigFilter(&hcan1, &FilterConfig0)!=HAL_OK) {
		Serialprintln("Error seting the CAN 1 Filter0");
	}
	else {
		Serialprintln("CAN 1 Filter0 Ready");
	}
	FilterConfig1.FilterIdHigh = 0<<5;
	FilterConfig1.FilterIdLow = 0;
	FilterConfig1.FilterMaskIdHigh = 0xffe0;
	FilterConfig1.FilterMaskIdLow = 0;
	FilterConfig1.FilterFIFOAssignment = CAN_FILTER_FIFO0;
	FilterConfig1.FilterBank = 1;
	FilterConfig1.FilterMode = CAN_FILTERMODE_IDMASK;
	FilterConfig1.FilterScale = CAN_FILTERSCALE_32BIT;
	FilterConfig1.FilterActivation =ENABLE;
	if(HAL_CAN_ConfigFilter(&hcan1, &FilterConfig1)!=HAL_OK) {
		Serialprintln("Error seting the CAN 1 Filter1");
	}
	else {
		Serialprintln("CAN 1 Filter1 Ready");
	}

	if(HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING)== HAL_OK) {
	  Serialprintln("Notifications for CAN 1 Active");
	}
	if(HAL_CAN_Start(&hcan1)!= HAL_OK) {
		Serialprintln("Error starting CAN 1");
	}
	else {
	  Serialprintln("CAN 1 Started!");
	}

  /* USER CODE END CAN1_Init 2 */

}
void CAN1_Tx(uint32_t ID, uint8_t dlc, uint8_t* data) {

	uint32_t TxMailbox;

	TxHeader1.DLC = dlc;
	TxHeader1.StdId = ID;
	TxHeader1.IDE = CAN_ID_STD;
	TxHeader1.RTR = CAN_RTR_DATA;

	if(HAL_CAN_AddTxMessage(&hcan1, &TxHeader1, data, &TxMailbox) != HAL_OK) {
		//Error_Handler();
		print("Failed to Add Message can 1\n");
	}
	print("Sending Message to can 1\n");
	while(HAL_CAN_IsTxMessagePending(&hcan1, TxMailbox));
	print("Message Sent to can 1\n");
}
void CAN1_Rx() {
	 HAL_CAN_GetRxMessage(&hcan1, CAN_RX_FIFO0, &RxHeader1, r1);

	 //dont forget to add and enable filters

	 switch(RxHeader1.StdId) {

	 case 0x000 :

		 break;
	 }
}
void print(char *msg, ...) {

	char buff[100];
	va_list args;
	va_start(args, msg);
	vsprintf(buff,msg,args);
#if USB_DEBUG
	HAL_UART_Transmit(&huart2, (uint8_t *)buff, strlen(buff), 10);
#endif
}
----------------------------------------------------------------------------------
/*
 * FLASH_SECTOR.h
 *
 *  Created on: May 15, 2020
 *      Author: controllerstech
 */

#ifndef INC_FLASH_SECTOR_H_
#define INC_FLASH_SECTOR_H_

#define START_F_ADDRESS_IP 0x08060000

uint32_t Flash_Write_Data (uint32_t StartSectorAddress, uint32_t * DATA_32, uint32_t numberofwords);
void Flash_Read_Data (uint32_t StartPageAddress, __IO uint32_t * DATA_32, uint32_t numberofwords);
void Convert_To_Str (uint32_t *data, char *str);


#endif /* INC_FLASH_SECTOR_H_ */

----------------------------------------------------------------------------------
FLASH_SECTOR.c

/*
 * FLASH_SECTOR.c
 *
 *  Created on: May 15, 2020
 *      Author: controllerstech
 */


#include "stm32f4xx_hal.h"
#include "FLASH_SECTOR.h"
#include "string.h"
#include "stdio.h"

/**
  * @brief  Gets the sector of a given address
  * @param  Address, the address in flash memory
  * @retval The sector of a given address
  */
static uint32_t GetSector(uint32_t Address) {
  uint32_t sector = 0;

  if((Address < 0x08003FFF) && (Address >= 0x08000000)) {
    sector = FLASH_SECTOR_0;
  }
  else if((Address <  0x08007FFF) && (Address >= 0x08004000)) {
    sector = FLASH_SECTOR_1;
  }
  else if((Address < 0x0800BFFF) && (Address >= 0x08008000)) {
    sector = FLASH_SECTOR_2;
  }
  else if((Address < 0x0800FFFF) && (Address >= 0x0800C000)) {
    sector = FLASH_SECTOR_3;
  }
  else if((Address < 0x0801FFFF) && (Address >= 0x08010000)) {
    sector = FLASH_SECTOR_4;
  }
  else if((Address < 0x0803FFFF) && (Address >= 0x08020000)) {
    sector = FLASH_SECTOR_5;
  }
  else if((Address < 0x0805FFFF) && (Address >= 0x08040000)) {
    sector = FLASH_SECTOR_6;
  }
  else if((Address <  0x0807FFFF) && (Address >= 0x08060000)) {
    sector = FLASH_SECTOR_7;
  }
  else if((Address < 0x0809FFFF) && (Address >= 0x08080000)) {
    sector = FLASH_SECTOR_8;
  }
  else if((Address < 0x080BFFFF) && (Address >= 0x080A0000)) {
    sector = FLASH_SECTOR_9;
  }
  else if((Address < 0x080DFFFF) && (Address >= 0x080C0000)) {
    sector = FLASH_SECTOR_10;
  }
  else if((Address < 0x080FFFFF) && (Address >= 0x080E0000)) {
    sector = FLASH_SECTOR_11;
  }
 /* else if((Address < 0x08103FFF) && (Address >= 0x08100000))
  {
    sector = FLASH_SECTOR_12;
  }
  else if((Address < 0x08107FFF) && (Address >= 0x08104000))
  {
    sector = FLASH_SECTOR_13;
  }
  else if((Address < 0x0810BFFF) && (Address >= 0x08108000))
  {
    sector = FLASH_SECTOR_14;
  }
  else if((Address < 0x0810FFFF) && (Address >= 0x0810C000))
  {
    sector = FLASH_SECTOR_15;
  }
  else if((Address < 0x0811FFFF) && (Address >= 0x08110000))
  {
    sector = FLASH_SECTOR_16;
  }
  else if((Address < 0x0813FFFF) && (Address >= 0x08120000))
  {
    sector = FLASH_SECTOR_17;
  }
  else if((Address < 0x0815FFFF) && (Address >= 0x08140000))
  {
    sector = FLASH_SECTOR_18;
  }
  else if((Address < 0x0817FFFF) && (Address >= 0x08160000))
  {
    sector = FLASH_SECTOR_19;
  }
  else if((Address < 0x0819FFFF) && (Address >= 0x08180000))
  {
    sector = FLASH_SECTOR_20;
  }
  else if((Address < 0x081BFFFF) && (Address >= 0x081A0000))
  {
    sector = FLASH_SECTOR_21;
  }
  else if((Address < 0x081DFFFF) && (Address >= 0x081C0000))
  {
    sector = FLASH_SECTOR_22;
  }
  else if (Address < 0x081FFFFF) && (Address >= 0x081E0000)
  {
    sector = FLASH_SECTOR_23;
  }*/
  return sector;
}

/**
  * @brief  Gets sector Size
  * @param  Sector, 32 bit value of the sector
  * @param  banks, the number of memory banks (1 or 2)
  * @retval The size of a given sector
  */
//static uint32_t GetSectorSize(uint32_t Sector, uint8_t banks) {
//  uint32_t sectorsize = 0x00;
//  if((Sector == FLASH_SECTOR_0) || (Sector == FLASH_SECTOR_1) || (Sector == FLASH_SECTOR_2) ||  (Sector == FLASH_SECTOR_3)) {
//    if(banks == 1) {
//    	sectorsize = 32 * 1024;
//    }
//    else if(banks == 2) {
//    	sectorsize = 16 * 1024;
//    }
//  }
//  else if((Sector == FLASH_SECTOR_4)) {
//    if(banks == 1) {
//    	sectorsize = 128 * 1024;
//    }
//    else if(banks == 2) {
//    	sectorsize = 64 * 1024;
//    }
//  }
//  else if((Sector == FLASH_SECTOR_5) || (Sector == FLASH_SECTOR_6) || (Sector == FLASH_SECTOR_7)|| (Sector == FLASH_SECTOR_8)|| (Sector == FLASH_SECTOR_9)|| (Sector == FLASH_SECTOR_10)|| (Sector == FLASH_SECTOR_11)) {
//    if(banks == 1) {
//    	sectorsize = 256 * 1024;
//    }
//    else if(banks == 2) {
//    	sectorsize = 128 * 1024;
//    }
//  }
//  // Uncomment below, if the device have more than 11 SECTORS
//
//  else if ((Sector == FLASH_SECTOR_12) || (Sector == FLASH_SECTOR_13) || (Sector == FLASH_SECTOR_14) || (Sector == FLASH_SECTOR_15)) {
//	sectorsize = 16 * 1024;
//  }
//
//  else if ((Sector == FLASH_SECTOR_16)) {
//	sectorsize = 64 * 1024;
//  }
//  else if ((Sector == FLASH_SECTOR_17) || (Sector == FLASH_SECTOR_18) || (Sector == FLASH_SECTOR_19)|| (Sector == FLASH_SECTOR_20)|| (Sector == FLASH_SECTOR_21)|| (Sector == FLASH_SECTOR_22)|| (Sector == FLASH_SECTOR_23)) {
//	sectorsize = 128 * 1024;
//  }
//  else {
//    sectorsize = 128 * 1024;
//  }
//
//  return sectorsize;
//}



uint32_t Flash_Write_Data (uint32_t StartSectorAddress, uint32_t * DATA_32, uint32_t numberofwords) {

	static FLASH_EraseInitTypeDef EraseInitStruct;
	uint32_t SECTORError;
	int sofar=0;

//	int numberofwords = (strlen(DATA_32)/4) + ((strlen(DATA_32) % 4) != 0);

//	int numberofwords = ((sizeof(DATA_32)/sizeof(uint32_t *))/4) + (((sizeof(DATA_32)/sizeof(uint32_t *)) % 4) != 0);

	 /* Unlock the Flash to enable the flash control register access *************/
	  HAL_FLASH_Unlock();

	  /* Erase the user Flash area */

	  /* Get the number of sector to erase from 1st sector */

	  uint32_t StartSector = GetSector(StartSectorAddress);
	  uint32_t EndSectorAddress = StartSectorAddress + numberofwords*4;
	  uint32_t EndSector = GetSector(EndSectorAddress);

	  /* Fill EraseInit structure*/
	  EraseInitStruct.TypeErase     = FLASH_TYPEERASE_SECTORS;
	  EraseInitStruct.VoltageRange  = FLASH_VOLTAGE_RANGE_3;
	  EraseInitStruct.Sector        = StartSector;
	  EraseInitStruct.NbSectors     = (EndSector - StartSector) + 1;

	  /* Note: If an erase operation in Flash memory also concerns data in the data or instruction cache,
	     you have to make sure that these data are rewritten before they are accessed during code
	     execution. If this cannot be done safely, it is recommended to flush the caches by setting the
	     DCRST and ICRST bits in the FLASH_CR register. */
	  if (HAL_FLASHEx_Erase(&EraseInitStruct, &SECTORError) != HAL_OK) {
		  return HAL_FLASH_GetError ();
	  }

	  /* Program the user Flash area word by word
	    (area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR) ***********/

	   while (sofar<numberofwords) {
	     if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, StartSectorAddress, DATA_32[sofar]) == HAL_OK) {
	    	 StartSectorAddress += 4;  // use StartPageAddress += 2 for half word and 8 for double word
	    	 sofar++;
	     }
	     else {
	       /* Error occurred while writing data in Flash memory*/
	    	 return HAL_FLASH_GetError ();
	     }
	   }

	  /* Lock the Flash to disable the flash control register access (recommended
	     to protect the FLASH memory against possible unwanted operation) *********/
	  HAL_FLASH_Lock();

	   return 0;
}

//@todo
// here we can add another parameter to specify the length of the data we are trying to read, so we would not need the while anymore
void Flash_Read_Data (uint32_t StartSectorAddress, __IO uint32_t * DATA_32, uint32_t numberofwords) {

	for(uint32_t i = 0; i < numberofwords; i++, StartSectorAddress += 4, DATA_32++) {
		*DATA_32 = *(__IO uint32_t *)StartSectorAddress;
	}
}

//void Convert_To_Str (uint32_t *data, char *str) {
//	int numberofbytes = ((strlen(data)/4) + ((strlen(data) % 4) != 0)) *4;
////	int numberofbytes = (((sizeof(data)/sizeof(uint32_t *))/4) + (((sizeof(data)/sizeof(uint32_t *)) % 4) != 0)) *4;
//
//	for (int i=0; i<numberofbytes; i++) {
//		str[i] = data[i/4]>>(8*(i%4));
//	}
//}
----------------------------------------------------------------------------------
